Binding and mutability
=================A variable can be used only if it has been initialized============================================
// Fix the error below with least amount of modification to the code

1.1
fn main() {

    let x: i32; // Uninitialized but used, ERROR !

    let y: i32; // Uninitialized but also unused, only a Warning !

    assert_eq!(x, 5);

    println!("Success!");

}

---------------------------------------------------------------------
// Fix this first problem by getting x initialized the reason it would cause an error is because assert_eq!(); is checking if x is equal to the number given and if its not it will send out a error and also because x is being used but not given a number to be initialized

1.2
fn main() {

    let x: i32 = 5; // Uninitialized but used, ERROR !

    let y: i32; // Uninitialized but also unused, only a Warning !

    assert_eq!(x, 5);

    println!("Success!");

}

----------------------------------------------------------------------
//you fix the warning by adding a _ infront of the y

1.3
fn main() {

    let x: i32 = 5; // Uninitialized but used, ERROR !

    let _y: i32; // Uninitialized but also unused, only a Warning !

    assert_eq!(x, 5);

    println!("Success!");

}

--------------------------------------------------------------------
//completed code

1.4
fn main() {

    let x: i32 = 5; // Uninitialized but used, ERROR !

    let _y: i32; // Uninitialized but also unused, only a Warning !

    assert_eq!(x, 5);

    println!("Success!");

}

===========================Use mut to mark a variable as mutable.===============================================
// Fill the blanks in the code to make it compile

2.1
fn main() {

    let __ __ = 1;

    __ += 2; 
    
    assert_eq!(x, 3);

    println!("Success!");

}

-------------------------------------------------------------
//first we need to fill in for x

2.2
fn main() {

    let __ x = 1;

    __ += 2; 
    
    assert_eq!(x, 3);

    println!("Success!");

}

--------------------------------------------------------------------------
//since we are changing the varible we need to let it know it can be changed

2.3
fn main() {

    let mut x = 1;

    __ += 2; 
    
    assert_eq!(x, 3);

    println!("Success!");

}

-----------------------------------------------------------------------------------
//now that the varible knows it can be changed we can then do the math below it by
adding the x

2.4
fn main() {

    let mut x = 1;

    x += 2; 
    
    assert_eq!(x, 3);

    println!("Success!");

}

------------------------------------------------------------------------------
//if you would like you can add a clearification to what varible is being used

2.5
fn main() {

    let mut x: i32 = 1;

    x += 2; 
    
    assert_eq!(x, 3);

    println!("Success!");

}

-----------------------------------------------------------------------------
//completed code

2.6
fn main() {

    let mut x: i32 = 1;

    x += 2; 
    
    assert_eq!(x, 3);

    println!("Success!");

}

Scope
==========================A scope is the range within the program for which the item is valid.==========================================================
// Fix the error below with least amount of modification

3.1
fn main() {

    let x: i32 = 10;

    {

        let y: i32 = 5;

        println!("The value of x is {} and value of y is {}", x, y);

    }

    println!("The value of x is {} and value of y is {}", x, y); 

}

----------------------------------------------------------------------------------
// as you can see the {} seperate the code in the middle meaning it will run like normal but any variables inside it can not be used outside of it so in order to make this work we would need to move out ley y: i32 = 10; outside the scope allowing it to be used

3.2
fn main() {

    let x: i32 = 10;
    let y: i32 = 5;

    {

        println!("The value of x is {} and value of y is {}", x, y);

    }

    println!("The value of x is {} and value of y is {}", x, y); 

}

-----------------------------------------------------------------------------------
//completed code

3.3
fn main() {

    let x: i32 = 10;
    let y: i32 = 5;

    {

        println!("The value of x is {} and value of y is {}", x, y);

    }

    println!("The value of x is {} and value of y is {}", x, y); 

}

=====================A scope is the range within the program for which the item is valid.========================================================
// Fix the error with the use of define_x

4.1
fn main() {

    println!("{}, world", x); 

}

fn define_x() {

    let x = "hello";

}

--------------------------------------------------------------------------------------------
//since in main we can not find x we must move it inside out function define_x()

4.2
fn main() {
     
}

fn define_x() {

    let x = "hello";

    println!("{}, world", x);

}

----------------------------------------------------------------------------------
// now we must call the function in the main function

4.3
fn main() {
     
    define_x();

}

fn define_x() {

    let x = "hello";

    println!("{}, world", x);

}

------------------------------------------------------------------------------------
//completed code

4.4
fn main() {
     
    define_x();

}

fn define_x() {

    let x = "hello";

    println!("{}, world", x);

}

Shadowing
======================You can declare a new variable with the same name as a previous variable, here we can say the first one is shadowed by the second one.=======================================================
// Only modify `assert_eq!` to make the `println!` work(print `42` in terminal)

5.1
fn main() {

    let x: i32 = 5;

    {

        let x = 12;

        assert_eq!(x, 5);

    }

    assert_eq!(x, 12);

    let x = 42;

    println!("{}", x); // Prints "42".

}

--------------------------------------------------------------------------------------------
//first we wull sloce the first two issues the main scope and sub scope in this case the inner scope does not worry about anything outside of it so we will need to change the inner assert_eq!(); to match the x inside the scope and by that we must change the main scope and main as in the first scope no main as in the function lets now change assert_eq!(); of the main scope to match the x variable

5.2
fn main() {

    let x: i32 = 5;

    {

        let x = 12;

        assert_eq!(x, 12);

    }

    assert_eq!(x, 5);

    let x = 42;

    println!("{}", x); // Prints "42".

}

------------------------------------------------------------------------------------------
//now that we solved those two small issues to get the printed result that we are looking for the upcomming x variable would in this case be shadowing out first x varible so we are reinitalizing x so make sure to keep it consitant by adding the variable type i32

5.3
fn main() {

    let x: i32 = 5;

    {

        let x = 12;

        assert_eq!(x, 12);

    }

    assert_eq!(x, 5);

    let x: i32 = 42;

    println!("{}", x); // Prints "42".

}

--------------------------------------------------------------------------------------------
//completed code

5.4
fn main() {

    let x: i32 = 5;

    {

        let x = 12;

        assert_eq!(x, 12);

    }

    assert_eq!(x, 5);

    let x: i32 = 42;

    println!("{}", x); // Prints "42".

}

===========================================================================================